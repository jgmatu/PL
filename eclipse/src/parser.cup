/********************************************************************/
/********************************************************************/
/*****          Autores: Ruben Morante Gonzalez                 *****/
/*****                   Francisco Javier                       *****/
/*****                   Jonathan                               *****/
/********************************************************************/
/********************************************************************/

package com.urjc.master.semv;

import com.urjc.master.semv.APITS.EnumType;
import java_cup.runtime.Symbol;


parser code{:

	private Ambito root;
	private Ambito actual;

	/* Es un método que el cual se llama automáticamente al haber un error en la gramática, 
	con el que informamos de la linea y la columna en el que se encuentra dicho error.*/
	@Override 
	public void syntax_error(Symbol s) { 
		int l = s.left + 1;
		int c = s.right + 1;
		report_error("\n   El String: '" + s.value + "' ha producido un error en la linea " + l + ", columna " + c + ".\n\n", null);
	}
:};

action code {:
	
	private Ambito root = new Ambito();
	private Ambito actual = this.root;
	
	private EnumType checkTypesOperation(String op, EnumType type1, EnumType type2) {		
		EnumType type = EnumType.ERROR;
		
		if (type1 == EnumType.ERROR || type2 == EnumType.ERROR) {
			return type;
		}
		
		if (type1 == type2) {
			type = type1;
		} else {
			System.err.println(" Incompatible types on " + op);			
		}
		return type;	
	}
		
:};

/* TOKENS */

// terminals
terminal treturn;
terminal l_par;
terminal r_par;
terminal l_brace;
terminal r_brace;
terminal l_bracket;
terminal r_bracket;
terminal comma;
terminal semicolon;
terminal assig;
terminal add;
terminal sub;
terminal mul;
terminal div;
terminal tif;
terminal tthen;
terminal telse;
terminal tfor;
terminal twhile;
terminal tdo;
terminal tuntil;
terminal tnot;
terminal tand;
terminal tor;
terminal equals;
terminal less;
terminal greater;
terminal lessequal;
terminal greaterequal;
terminal include;
terminal hfile;
terminal constint;
terminal constfloat;
terminal String tvoid;
terminal String tint;
terminal String tfloat;
//terminal tboolean;
terminal String tid;

// non terminals
non terminal PROGRAM;
non terminal PART;
non terminal BLQ;
non terminal SENTLIST;
non terminal SENT;
non terminal EXP;
non terminal EXPT;
non terminal FACTOR;
non terminal EnumType TYPE;
non terminal Lid LID;
non terminal ListParams LISTPARAM;
non terminal Command RESTPART;
non terminal LCOND;
non terminal LCONDT;
non terminal LCONDF;
non terminal COND;
non terminal OPR;

/* GRAMMAR */
PROGRAM ::= PART PROGRAM {:
	;
:};

PROGRAM ::= PART {:
//	System.out.println(this.actual.toString());
	System.err.println("FIN DE PROGRAMA"); 	
:};

/**
* De esta manera RESTPAR devuelve command 
* podríamos tener variables globales, aunque no esté
* contemplado, habría que hacer el sintáctico de variable 
* global, pero se puede dejar así para solo funciones...
*
* NOTE: De la clase Command heredan las funciones y las variables que luego se 
* insertan en el ambito...
*/
PART ::= TYPE:type RESTPART:command {: 	

	Command err = this.actual.buscaError();
	if (err != null) {
		this.actual.deleteError(err);
	}	

	if (command != null && command instanceof Function) {
		Function function = (Function) command;
		function.insertaTipo(type);		
	}
:};

/**
 * Definición de función
 *
 */
RESTPART ::= tid:idLexema l_par LISTPARAM:list {:

	boolean success = this.root.insertaIdFunction(idLexema);
	Function function = null;
	
	if (success) {
		function = (Function) this.root.buscaId(idLexema);
	} else {
		function = (Function) this.root.buscaId(Ambito.ERROR_PREFIX + idLexema);
	}
	this.actual = function.getAmbito();
	function.insertarParametros(list);
	
	RESULT = function;
	
:} r_par BLQ;

/*
 * Definición de función
 */
RESTPART ::= tid:idLexema l_par tvoid r_par {: 
	boolean success = this.root.insertaIdFunction(idLexema);
	Function function = null;
	
	if (success) {
		function = (Function) this.root.buscaId(idLexema);
	} else {
		function = (Function) this.root.buscaId(Ambito.ERROR_PREFIX + idLexema);
	}
	this.actual = function.getAmbito();

	RESULT = function;
:} BLQ;


LISTPARAM ::= LISTPARAM:listparams comma TYPE:type tid:id {: 

	listparams.insertar(id, type);
	RESULT = listparams;		

:};

LISTPARAM ::= TYPE:type tid:id {: 

	ListParams listparams = new ListParams();
	listparams.insertar(id, type);
	RESULT = listparams;
	
:};

BLQ ::= l_brace SENTLIST r_brace {: 	
	// Manejo de errores al cierre del ámbito...
	Command err = this.actual.buscaError();
	if (err != null) {
		this.actual.deleteError(err);
	}
//	System.out.println(this.actual.toString());
	this.actual = this.actual.getFather();
:};

SENTLIST ::= SENTLIST SENT;
SENTLIST ::= SENT;

// Declare id's...
SENT ::= TYPE:type LID:lid {: 
	for(String id : lid.getList()) {
		this.actual.insertaIdVariable(new Variable(id, type));
	}	
:} semicolon;


// Assign...
SENT ::= tid:idLexema assig EXP:typeExp semicolon {: 
	EnumType type = EnumType.ERROR;	
	Command cmd = this.actual.buscaId(idLexema);

	if (cmd == null) {
		System.err.println("No existe el identificador de la assignación");
	} else if (typeExp != EnumType.ERROR) {
		if (cmd.dameTipo() == typeExp) {
			type = EnumType.VOID;
		} else {
			System.err.println("Incompatible types in assgin...");
		}
	}
	RESULT = type;
:};

// Call function...
SENT ::= tid l_par LID r_par semicolon {: 
	// System.err.println("Llamada a función!!"); 
:};

// return....
SENT ::= treturn EXP:type semicolon {: 
	// System.err.println("Return statement");
:};


// if then else...
SENT ::= tif l_par LCOND r_par tthen {: 

	this.actual = new Ambito(this.actual);

:} BLQ telse {: 

	this.actual = new Ambito(this.actual);

:} BLQ;

SENT ::= tif l_par LCOND r_par tthen {:

	this.actual = new Ambito(this.actual);
	System.err.println("if statement no else end BLQ..."); 

:} BLQ;

// for...
SENT ::= tfor l_par tid assig EXP semicolon LCOND semicolon tid assig EXP r_par {:

	this.actual = new Ambito(this.actual);

:} BLQ; 

// while ..
SENT ::= twhile l_par LCOND r_par {:

	this.actual = new Ambito(this.actual);

:} BLQ;

// do while...
SENT ::= tdo {:

	this.actual = new Ambito(this.actual);

:} BLQ tuntil l_par LCOND r_par;

// Bloque anonimo
SENT ::= {:

	this.actual = new Ambito(this.actual);

:} BLQ;

SENT ::= semicolon {:
	// System.err.println("NOP instruction...."); 	
:};

LID ::= tid:id {: 

	Lid lid = new Lid();
	lid.add(id);
	RESULT = lid; 

:};

LID ::= tid:id comma LID:lid {:

	lid.add(id);
	RESULT = lid; 
	
:}; // Devolver tipo de tid a LID...

// LID ::= /* empty */;

EXP ::= EXP:typeExp add EXPT:typeExpt {:
	EnumType type1 = (EnumType) typeExp;
	EnumType type2 = (EnumType) typeExpt; 
	RESULT = checkTypesOperation("add", type1, type2);
:};

EXP ::= EXP:typeExp sub EXPT:typeExpt {:
	EnumType type1 = (EnumType) typeExp;
	EnumType type2 = (EnumType) typeExpt; 
	RESULT = checkTypesOperation("sub", type1, type2);
:};

EXP ::= EXPT:type {:	
	RESULT = type;
:};

EXPT ::= EXPT:typeExpr mul FACTOR:typeFactor {:
	EnumType type1 = (EnumType) typeExpr;
	EnumType type2 = (EnumType) typeFactor; 
	RESULT = checkTypesOperation("mul", type1, type2);
:};

EXPT ::= EXPT:typeExpr div FACTOR:typeFactor {:
	EnumType type1 = (EnumType) typeExpr;
	EnumType type2 = (EnumType) typeFactor; 
	RESULT = checkTypesOperation("div", type1, type2);
:};

EXPT ::= FACTOR:type {:	
	RESULT = type;
:};

// Llamada a función evaluar...
FACTOR ::= tid:idLexema l_par LID:lid r_par {:
	Function func = null;
	Command cmd = null;
	EnumType type = EnumType.ERROR;
		
	cmd = this.actual.buscaId(idLexema);
	if (cmd == null && !(cmd instanceof Function)) {
		System.err.println("The function not exist..");
		type = EnumType.ERROR;
	} else {
		func = (Function) cmd;
		type = cmd.getTipo();
	}
	
	if (type != EnumType.ERROR && func != null) {
		TupleTypes idTypes_1 = this.actual.buscaIdsType(lid);
		TupleTypes idTypes_2 = func.getParamsTypes();
		boolean success = idTypes_1.compare(idTypes_2);
		if (!success) {
			type = EnumType.ERROR;
		}
	} else {
		type = EnumType.ERROR;
	}
	RESULT = type;
:};

FACTOR ::= l_bracket EXP r_bracket;
FACTOR ::= tid;
FACTOR ::= constint {:
	RESULT = EnumType.INT;
:};
FACTOR ::= constfloat {:
	RESULT = EnumType.FLOAT;
:};

TYPE ::= tvoid:v {: RESULT =  EnumType.VOID; :};
TYPE ::= tint:i {: RESULT =  EnumType.INT; :};
TYPE ::= tfloat:f {: RESULT =  EnumType.FLOAT; :};

LCOND ::= LCOND tor LCONDT;
LCOND ::= LCONDT;

LCONDT ::= LCONDT tand LCONDF;
LCONDT  ::=  LCONDF;

LCONDF ::= COND;
LCONDF ::= tnot COND;

COND ::= EXP OPR EXP;

OPR ::=  equals;
OPR ::=  less;
OPR ::=  greater;
OPR ::=  greaterequal;
OPR ::=  lessequal;
