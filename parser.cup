/********************************************************************/
/********************************************************************/
/*****          Autores: Ruben Morante Gonzalez                 *****/
/*****                   Francisco Javier                       *****/
/*****                   Jonathan                               *****/
/********************************************************************/
/********************************************************************/

import java.util.ArrayList;
// import java_cup.runtime.Symbol;

parser code{:
	private Ambito root;
	private Ambito actual;

	public Ambito getAmbitoRoot() {
		return this.root;
	}

	public Ambito setAmbitoRoot(Ambito ambito) {
		this.root = ambito;
	}

	public Ambito getAmbitoActual() {
		return this.actual;
	}

	public Ambito setAmbitoActual(Ambito ambito) {
		this.actual = ambito;
	}

	/*Es un método que el cual se llama automáticamente al haber un error en la gramática, 
	con el que informamos de la linea y la columna en el que se encuentra dicho error.*/
	@Override 
	public void syntax_error(Symbol s) { 
		int l = s.left + 1;
		int c = s.right + 1;
		report_error("\n   El String: '" + s.value + "' ha producido un error en la linea " + l + ", columna " + c + ".\n\n", null);
	}
:};

action code {:
	private Ambito root = new Ambito();
	private Ambito actual = new Ambito();

	public Ambito getAmbitoRoot() {
		return this.root;
	}
:};

/* TOKENS */

// terminals
terminal treturn;
terminal l_par;
terminal r_par;
terminal l_brace;
terminal r_brace;
terminal l_bracket;
terminal r_bracket;
terminal comma;
terminal semicolon;
terminal assig;
terminal add;
terminal sub;
terminal mul;
terminal div;
terminal tif;
terminal tthen;
terminal telse;
terminal tfor;
terminal twhile;
terminal tdo;
terminal tuntil;
terminal tnot;
terminal tand;
terminal tor;
terminal equals;
terminal less;
terminal greater;
terminal lessequal;
terminal greaterequal;
terminal include;
terminal hfile;
terminal constint;
terminal constfloat;
terminal String tvoid;
terminal String tint;
terminal String tfloat;
//terminal tboolean;
terminal String tid;

// non terminals
non terminal PROGRAM;
non terminal PART;
non terminal BLQ;
non terminal SENTLIST;
non terminal SENT;
non terminal EXP;
non terminal EXPT;
non terminal FACTOR;
non terminal String TYPE;
non terminal LID LID;
non terminal LISTPARAM;
non terminal RESTPART;
non terminal LCOND;
non terminal LCONDT;
non terminal LCONDF;
non terminal COND;
non terminal OPR;

/* GRAMMAR */
PROGRAM ::= PART PROGRAM;
PROGRAM ::= PART;


PART ::= TYPE:type RESTPART {: System.out.println("PART TYPE : " + type); :};


RESTPART ::= tid:idLexema l_par LISTPARAM:list {:
 System.out.println("
 	RESTPART this.root.InsertaId(idLexema, APITS.EnumCommands.FUNCTION, this.root);
 	Function function = (Function) this.root.buscaId(idLexema);
 	function.insertarParametros(list));
 	this.setAmbitoActual(function.getAmbito());
 "); :} r_par BLQ;

RESTPART ::= tid:idLexema l_par tvoid r_par {: 
	System.out.println("
		RESTPART.void 
		this.root.InsertaId(idLexema, APITS.EnumCommands.FUNCTION, this.root);
		Function function = (Function) this.root.buscaId(idLexema);
		this.setAmbitoActual(function.getAmbito());
	"); :} BLQ;


LISTPARAM ::= LISTPARAM:listparam comma TYPE:type tid:id {: 
	System.out.println("
		LISTPARAM TYPE comma: " + type +"
		listparam.insertar(id, type);
		RETURN = listparam;
	"); :};
LISTPARAM ::= TYPE:type tid:id {: 
	System.out.println("
		LISTPARAM TYPE: " + type + "
		LISTPARAM listparam = new LISTPARAM();
		listparam.insertar(id, type);
		RETURN = listparam;
	"); :};

BLQ ::= l_brace {: System.out.println("NuevoEntorno"); :} SENTLIST r_brace {: 
	System.out.println("
		Salir Entorno
		this.setAmbitoActual(this.getAmbitoActual().getFather());
	"); :};

SENTLIST ::= SENTLIST SENT;
SENTLIST ::= SENT;


SENT ::= TYPE:type LID:lid  {: 
	System.out.println("
		for(String id : lid.getList()) {
			this.actual.insertaId(type, id, APITS.EnumCommands.VARIABLE);
		}
	"); :} semicolon;
SENT ::= tid assig EXP semicolon;
SENT ::= tid l_par LID r_par semicolon;
SENT ::= treturn EXP semicolon;
SENT ::= tif l_par LCOND r_par tthen BLQ telse BLQ;
SENT ::= tfor l_par tid assig EXP semicolon LCOND semicolon tid assig EXP r_par BLQ;
SENT ::= twhile l_par LCOND r_par BLQ;
SENT ::= tdo BLQ tuntil l_par LCOND r_par;
SENT ::= BLQ;

LID ::= tid:id {: 
	System.out.println("
		LID lid = LID();
		lid.add(id);
		RESULT = lid;  
	"); :};
LID ::= tid:id comma LID:lid {:
	System.out.println("
		lid.add(id);
		RESULT = lid; 
	"); :}; // Devolver tipo de tid a LID...
// LID ::= /* empty */;

EXP ::= EXP add EXPT;
EXP ::= EXP sub EXPT;
EXP ::= EXPT;


EXPT ::= EXPT mul FACTOR;
EXPT ::= EXPT div FACTOR;
EXPT ::= FACTOR;

FACTOR ::= tid l_par LID r_par;
FACTOR ::= l_bracket EXP r_bracket;
FACTOR ::= tid;
FACTOR ::= constint;
FACTOR ::= constfloat;

TYPE ::= tvoid:v {: System.out.println("Type Void BLA : " + v); RESULT = v; :};
TYPE ::= tint:i {: System.out.println("Type  Int: BLA " + i); RESULT = i; :};
TYPE ::= tfloat:f {: System.out.println("Type  Float: BLA " + f); RESULT = f; :};

LCOND ::= LCOND tor LCONDT;
LCOND ::= LCONDT;

LCONDT ::= LCONDT tand LCONDF;
LCONDT  ::=  LCONDF;

LCONDF ::= COND;
LCONDF ::= tnot COND;


COND ::= EXP OPR EXP;

OPR ::=  equals;
OPR ::=  less;
OPR ::=  greater;
OPR ::=  greaterequal;
OPR ::=  lessequal;
